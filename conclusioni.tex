\chapter{Conclusioni e direzioni future di ricerca}
\label{Conclusioni}
\thispagestyle{empty}

\noindent In questo lavoro di tesi abbiamo presentato una soluzione al problema di identificare particolari eventi che possano compromettere la corretta ripresa della scena in un sistema di monitoraggio video, a cui si fa riferimento con il termine tampering.
In particolare abbiamo considerato l'utilizzo di camere intelligenti alimentate a batteria e lo scenario in cui la frequenza di acquisizione delle immagini da parte del sensore sia bassa, ad esempio un frame ogni minuto.\\
Abbiamo visto come lo scenario a basso consumo energetico ci imponga l'utilizzo di algoritmi a bassa complessit\`a computazionale. Questo non ci permette di utilizzare degli indicatori troppo onerosi da estrarre dalle immagini.
Inoltre abbiamo visto come il fatto di considerare dei framerate bassi complichi l'identificazione di eventi di tampering, in quanto le differenze tra frame consecutivi sono molto pi\`u elevate rispetto al caso di acquisizione continua. \\
La soluzione che abbiamo proposto \`e stata di utilizzare degli indicatori a bassa complessit\`a computazionale da ciascuna immagine, e di monitorarli nel tempo con tecniche one-shot e sequenziali, in modo da individuare cambiamenti nel loro comportamento associabili a eventi di tampering.
Gli indicatori fanno riferimento a specifiche regioni della scena inquadrata dalla camera, che vengono estratte da un algoritmo di segmentazione della scena, eseguito prima della messa in opera del sistema.\\
Abbiamo condotto delle analisi sperimentali utilizzando sequenze di immagini acquisite a basso framerate, in modo da verificare le prestazioni del nostro algoritmo.
Le prove sperimentali condotte hanno dimostrato come l'utilizzo della segmentazione della scena porti a dei miglioramenti nelle prestazioni dell'algoritmo, diminuendo il numero di falsi allarmi, senza aggiungere complessit\`a computazionale.
Un monitoraggio sequenziale sulla varianza dell'energia media del gradiente, inoltre, ha permesso di identificare alcuni eventi di sfocatura non individuate dal monitoraggio one-shot.\\
Gli sviluppi futuri riguarderanno il miglioramento dell'algoritmo e la sua integrazione su un dispositivo.
Per quanto riguarda l'identificazione di sfocature la ricerca dovr\`a essere condotta su come combinare il monitoraggio sequenziale con quello one-shot.
Per come \`e stato realizzato l'algoritmo al momento, infatti, le due tecniche sono eseguite in parallelo, e la prima che identifica un cambiamento solleva l'allarme.
Combinare le due tecniche, ad esempio utilizzando il monitoraggio sequenziale come \textit{validazione} degli allarmi lanciati dal monitoraggio one-shot, potrebbe portare a un miglioramento delle prestazioni, riducendo il numero di falsi allarmi e, di conseguenza, il consumo energetico dovuto alla trasmissione di segnali inutili.\\
Per quanto riguarda l'identificazione di spostamenti della camera un ulteriore sviluppo potrebbe riguardare l'integrazione delle informazioni estratte dalle immagini della camera con i dati forniti da dispositivi MEMS (\textit{Micro Electro-Mechanical Systems}), in modo da poter validare gli allarmi ricevuti dalla camera.
Dato il loro basso costo e il ridotto consumo energetico, infatti, \`e ragionevole considerare che le camere utilizzati possano essere fornite di questi particolari dispositivi.
Uno scenario possibile, ad esempio, potrebbe essere quello in cui abbiamo dei sensori inerziali che forniscono un'acquisizione \textit{continua} di dati accelerometrici e giroscopici. 
I dati estratti dalla camera possono essere utilizzati come un'\textit{informazione aggiuntiva} per validare l'identificazione di un evento di spostamento della camera da parte del sensore inerziale.\\
La fase finale dello sviluppo dovrebbe consistere nell'integrazione dell'algoritmo su un prototipo di smart camera di \textit{STMicroelectorics}.
L'integrazione passa prima di tutto da un'ottimizzazione del codice del nostro algoritmo, in modo che rispetti alcuni vincoli determinati dallo hardware del dispositivo su cui deve essere eseguito.
%a riscrittura del codice MATLAB in C, rispettando alcuni vincoli di ottimizzazione del codice.
In seguito sar\`a possibile accelerare alcune funzioni direttamente in hardware, in modo da aumentare le prestazioni e ridurre il consumo energetico.\\



